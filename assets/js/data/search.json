[ { "title": "Baekjoon 10818", "url": "/posts/TIL/", "categories": "TIL, C++, Baekjoon", "tags": "C++, Baekjoon, TIL", "date": "2023-01-02 00:00:00 +0900", "snippet": "Baekjoon 10818Baekjoon 10818 : 최소, 최대문제N개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.입력첫째 줄에 정수의 개수 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에는 N개의 정수를 공백으로 구분해서 주어진다. 모든 정수는 -1,000,000보다 크거나 같고, 1,000,000보다...", "content": "Baekjoon 10818Baekjoon 10818 : 최소, 최대문제N개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.입력첫째 줄에 정수의 개수 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에는 N개의 정수를 공백으로 구분해서 주어진다. 모든 정수는 -1,000,000보다 크거나 같고, 1,000,000보다 작거나 같은 정수이다.출력첫째 줄에 주어진 정수 N개의 최솟값과 최댓값을 공백으로 구분해 출력한다.예제입력 1520 10 35 30 7예제출력 17 35CODE (C++)#include &lt;iostream&gt;using namespace std;int main (void){ int num; cin&gt;&gt;num; int k[num]; int i; for(i=0;i&lt;num;i++){ cin&gt;&gt;k[i]; } int max = k[0]; int min = k[0]; for(i=0;i&lt;num;i++){ if (min&gt;k[i]){ min=k[i]; } if (max&lt;k[i]){ max=k[i]; } } cout&lt;&lt;min&lt;&lt;' '&lt;&lt;max&lt;&lt;endl;} 첫 줄에 몇 개의 정수를 입력할 것인지 그 수를 입력받는다.→ num 변수를 선언하여 cin으로 입력받음 num 수만큼 정수를 입력받는다.→ int형 배열을 선언 → k[num]→ for문을 이용 수를 cin으로 입력받음 max, min 선언 및 비교→ int형으로 두 변수를 선언한 뒤→ for문으로 비교하며 min보다 작은 수라면 그 수를 min에 할당, max보다 큰 수라면 그 수를 max에 할당 cout으로 min과 max를 출력Tip 첫 시도 때, for문 문법을 파이썬과 헷갈려서 for i in range (0,num)으로 적었다. c와 python은 문법이 다르니 주의하자 ! 배열은 항상 [0]부터 시작해 [end-1]까지임을 기억하자 ! ‘ ‘와 “ “의 차이를 기억하자 ! ‘ ‘은 character이며 하나의 문자이다. “ “은 string이며, 하나 이상의 문자열이다." }, { "title": "What is python turtle", "url": "/posts/TIL/", "categories": "TIL, python turtle", "tags": "python turtle, TIL", "date": "2022-12-02 00:00:00 +0900", "snippet": "백준 문제를 풀기 위해 파이썬을 실행하다가python turtle을 잘못 실행해 오류가 발생했다.처음 보는 것이었기에, 무엇인지 궁금해 찾아보았다.1. Python Turtle파이썬 터틀은 파이썬의 ‘그래픽 모듈’이라고 한다.python turtle을 실행하면 거북이가 지나다니며 선을 그린다.2. 간단한 명령어t.forward() : 입력한 숫자만큼 ...", "content": "백준 문제를 풀기 위해 파이썬을 실행하다가python turtle을 잘못 실행해 오류가 발생했다.처음 보는 것이었기에, 무엇인지 궁금해 찾아보았다.1. Python Turtle파이썬 터틀은 파이썬의 ‘그래픽 모듈’이라고 한다.python turtle을 실행하면 거북이가 지나다니며 선을 그린다.2. 간단한 명령어t.forward() : 입력한 숫자만큼 앞으로 움직이기t.left() : 입력한 숫자만큼 각도 바꾸기t.right() : 입력한 숫자만큼 오른쪽으로 각도 바꾸기t.back() : 입력한 숫자만큼 뒤로 움직이기t.setheading(숫자) : 거북이가 바라보는 방향 바꾸기t.clear() : 거북이의 위치, 방향은 그대로 둔 채 화면 지우기t.speed(숫자) : 거북이의 속도 조절 (빠른 속도 10, 최고 속도 0, 느린 속도 1)t.shaped(문자열) : 거북이의 모양 바꾸기 ~ \"turtle\", \"sqare\", \"arrow\"t.listen() : 사용자 입력이 잘 처리되도록 거북이 그래픽 창에 포커스 주기t.onekeypress(함수이름, 문자열) : 키보드를 눌럿을 때 지정한 함수를 실행t.penup() : 펜을 올리기t.pendown() : 펜을 내리기t.bgcolor('color') : 배경색 바꾸기t.color('color') : 펜 색 바꾸기3. 이용해보기아래는 repelit에서 제공하는 기본 코드이다 !import turtlet = turtle.Turtle()for c in ['red', 'green', 'blue', 'yellow']: t.color(c) t.forward(75) t.left(90) 이와 같은 그림이 나온다.인터넷을 찾아 여러 예제를 더 실행시켜보았다.별그리기 !import turtlet = turtle.Turtle()t.shape(\"turtle\")for i in range(5): t.forward(100) t.left(144)아래를 코드를 추가해주면 노랑색이 나온다 !t.color('yellow')그런데 이런 turtle은 왜 쓰는것일까 ! 해서 찾아봤더니터틀은 어린이 및 초보자가 파이썬을 쉽게 배울 수 있도록 만든 모듈이라고 한다.나한테도 확실히 재밌으니 성공인 것 같다 !import turtlet = turtle.Turtle()t.shape(\"turtle\")t.color('blue')t.penup()t.left(180)t.forward(80)t.right(90)t.forward(40)t.pendown()t.right(90)t.forward(35)t.right(135)t.forward(35)t.penup()t.back(25)t.pendown()t.left(90)t.forward(25)t.penup()t.right(135)t.forward(15)t.left(90)t.pendown()t.forward(10)t.left(90)t.forward(20)t.left(180)t.forward(40)t.penup()t.left(90)t.forward(10)t.left(90)t.forward(20)t.right(90)#downt.forward(10)t.right(90)t.forward(10)t.left(90)t.pendown()#circlea=10for i in range(a): t.forward(8) t.left(360/a)t.penup()t.left(90)t.forward(40)t.left(90)t.forward(50)t.pendown()t.right(90)t.forward(30)t.right(90)t.forward(40)t.penup()t.left(90)t.forward(8)t.left(90)t.pendown()t.forward(40)t.back(20)t.right(90)t.forward(8)t.back(8)t.right(90)t.forward(20)t.penup()t.forward(15)t.right(90)t.forward(8)t.left(90)t.pendown()a=10for i in range(a): t.forward(8) t.left(360/a)활용편 ㅎㅎ" }, { "title": "Reminding C language 2", "url": "/posts/TIL/", "categories": "Study, Programming_Language", "tags": "C", "date": "2022-12-01 00:00:00 +0900", "snippet": "오랜만에 깃허브를 다시 열었다.12월 1일이 됐겠다, 2022년 멋지게 마무리하고 2023년에도 멋진 대학생으로 살기 위해서 ! !스타트를 끊어보려고 한다.비록 지금 시험기간이라 많은 시간을 쏟지는 못하지만, 하루에 20분이라도 이렇게 투자해보려 한다. 물론 다다음주 시험만 끝나면 열심히, 꾸준히 포스팅할 계획 !백준도 함께 시작하기 위해 hanoi ...", "content": "오랜만에 깃허브를 다시 열었다.12월 1일이 됐겠다, 2022년 멋지게 마무리하고 2023년에도 멋진 대학생으로 살기 위해서 ! !스타트를 끊어보려고 한다.비록 지금 시험기간이라 많은 시간을 쏟지는 못하지만, 하루에 20분이라도 이렇게 투자해보려 한다. 물론 다다음주 시험만 끝나면 열심히, 꾸준히 포스팅할 계획 !백준도 함께 시작하기 위해 hanoi 문제를 풀어봤는데 문제 조건에 어긋나는지 자꾸 틀린다.블로그 작성하고 나서 다시 해봐야겠다.뭐라도 하고싶어서 간단한 문제라도 풀어봤다.#include &lt;stdio.h&gt;int main(void) { char c; scanf(\"%c\", &amp;c); printf(\"%d\", (int)c); return 0;}ASCII 코드로 출력하는 문제다.간단해보여도 ASCII 코드는 요긴하게 쓰이는 것 같다 ! 그러니까 리마인드 해두자.#include &lt;stdio.h&gt;#include &lt;math.h&gt;void hanoi(int n, int from, int by, int to) { if (n == 1) printf(\"%d %d\\n\", from, to); else { hanoi(n - 1, from, to, by); printf(\"%d %d\\n\", from, to); hanoi(n - 1, by, from, to); }}int main(void) { int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", (int)(pow(2,n))-1); hanoi(n, 1, 2, 3); return 0;}내가 작성한 하노이 코드… 뭘 더 고쳐야할지 생각해봐야겠다." }, { "title": "TIL - C++/2022.10.05", "url": "/posts/TIL-2022.10.05/", "categories": "TIL, C++", "tags": "TIL, C++", "date": "2022-10-04 00:00:00 +0900", "snippet": "Learning Rvalue and Lvalue in referenceLast Posting에서 Data Structure 5번에 대한 고찰(😆)을 업로드했는데, 과제 제출을 위해 더 알아보며 새롭게 알게 된 내용을 기반으로 다시 한 번 작성해보려 한다. 😊Error codeFirst, Let’s see the problem code !#includ...", "content": "Learning Rvalue and Lvalue in referenceLast Posting에서 Data Structure 5번에 대한 고찰(😆)을 업로드했는데, 과제 제출을 위해 더 알아보며 새롭게 알게 된 내용을 기반으로 다시 한 번 작성해보려 한다. 😊Error codeFirst, Let’s see the problem code !#include &lt;iostream&gt;using namespace std;int main(int argac, char** argv){ int y=1; int *&amp; ry = &amp;y; cout &lt;&lt;ry&lt;&lt;endl; return 0;}→ Error occurs ! ! ! → The error says that &lt;non-const lvalue reference to type ‘int*’ cannot bind to a temporary of type ‘int *’&gt;What is the code is representing ? 😎It seems to represent “Reference to the pointer variable”, because it uses “*&amp;” → *&amp; 을 보아 위의 코드는 포인터 변수에 대한 참조자(reference)에 대해 나타내고있다. (&amp;을 통해 참조하는 것을 인식, *을 통해 포인터 변수를 참조하는 것을 인식)Lvalue and RvalueTo analyze above code and error, we should know the concept of Lvalue and Rvalue !→ 위의 코드와 에러를 분석하기 위해서, 우리는 Lvalue 와 Rvalue 의 개념을 알아야한다. Lvalue Lvalue means an object that has an identifiable location in memory(→ having an address) // Lvalue 는 메모리에 위치를 식별할 수 있는 대상 Its reference is ‘&amp;’ Rvalue Rvalue means an object that has no identifiable location in memory //rvalue는 메모리에 위치를 식별할 수 없는 대상(메모리에 저장X) Its reference is ‘&amp;&amp;’ ⇒ Lvalue can appear on the left of an assignment operator while Rvalue can appear on the right~ 즉 쉽게 설명하면 assignment에서 (=)의 왼쪽에 올 수 있는 것이 lvalue이고, 오른쪽에만 올 수 있는 것이 rvalue이다. (lvalue는 때에 따라 오른쪽에 올 수도 있음 !)for example)int x=100 // x is lvalue and y is rvalueint y=x // y is lvalue and y is also lvalueCan you understand ? 여기까지 이해가 가시나요? 😁we can obtain more realization in this websitelvalue and rvalue in C language - GeeksforGeeksReturn to the code#include &lt;iostream&gt;using namespace std;int main(int argac, char** argv){ int y=1; // y is lvalue , 1 is rvalue int *&amp; ry = &amp;y; //error line !!!\t\t\t\t// *&amp; ry is reference of lvalue, &amp;y is rvalue (address of y) cout &lt;&lt;ry&lt;&lt;endl; return 0;}Let’s see the error line ! error가 발생하는 line을 보자.int *&amp; ry = &amp;y;‘*&amp;ry’is the reference of Lvalue , especially pointer variable because of ‘*’.But, ‘&amp;y’ is Rvalue !*&amp;ry는 분명히 Lvalue 인 포인터변수에 대한 참조자로 쓰여야하는데,&amp;y는 Rvalue 이다.앞서 Rvalue 에 대한 참조자는 &amp;&amp;이며, 에 대한 참조자가 `&amp;`라고 설명한 것을 보아, error가 발생할 수밖에 없음을 알 수 있다.Solution use ‘&amp;&amp;’ whicjh is tjhe reference of Rvalue int *&amp;&amp;ry = &amp;y; // &amp;y is rvalue and &amp;&amp; is reference to rvalue make ‘&amp;y’ to Lvalue int *k = &amp;y; // k is lvalue, &amp;y is rvalueint *&amp;ry = k; // k is lvalue and &amp; is reference to lvalueIn this way, error doesn’t occur.The result would be the address of ‘y’Finally : analyze the error codeLet’s see the error code.→ error : non-const lvalue reference to type ‘int *’ cannot bind to a temporary of type ‘int *’error 문장을 분석해보면,non-const lvalue reference는 &amp; 을 이야기한다. non-const라는 말은 const로 만들면 lvalue reference도 사용 가능한데, 그렇게 하지 않았기때문에 lvalue reference는 사용할 수 없음을 이야기한다. (non-const에 대해서는 깊게 이야기 할 부분이 아니다)to type ‘int *’은 포인터 변수를 참조하는것이기때문에 나온 것으로, 만약 just 정수를 참조했다면 ‘int’라 뜰 것이다.temporary는 rvalue를 이야기한다.즉, lvalue의 reference인 &amp; 로는 rvalue를 bind(묶다, 엮다) 할 수 없다는 오류가 뜬 것을 분석할 수 있다.Find solution from the error !지금껏 error code에 대해 그리 깊은 주의를 기울인 적은 없었다.프로그래밍에 입문한 지 얼마 되지 않아 프로그래밍 용어를 잘 모르기도 했고, 기본적으로 영어를 잘 못하기 때문도 있었다.그러나 이번 과제를 해결하면서, error code의 중요성을 깨달았다. error code를 분석하고 공부하는 과정에서 새로운 개념인 lvalue와 rvalue에 대해 알게 되었기 때문이다.앞으로는 error code도 허투로 보지 말고, 스스로 생각해보고, 답을 찾기 위해 구글링을 하는 노력도 필요함을 잊지 말자 !" }, { "title": "TIL - C++/2022.10.03", "url": "/posts/TIL-2022.10.03/", "categories": "TIL, C++", "tags": "TIL, C++", "date": "2022-10-03 00:00:00 +0900", "snippet": "1. 객체(object)객체 (object) : 상태정보 (데이터) / 행동(기능)상태정보 =&gt; 변수행동 =&gt; 함수객체 생성을 위한 틀(mold) ~&gt; 클래스! (class)ex. 붕어빵 틀 생각상수 =&gt; const 선언 ! (예를 들어, 사과 가격)2. 객체 생성 방식(1) className objectName ; // 일반적인...", "content": "1. 객체(object)객체 (object) : 상태정보 (데이터) / 행동(기능)상태정보 =&gt; 변수행동 =&gt; 함수객체 생성을 위한 틀(mold) ~&gt; 클래스! (class)ex. 붕어빵 틀 생각상수 =&gt; const 선언 ! (예를 들어, 사과 가격)2. 객체 생성 방식(1) className objectName ; // 일반적인 변수의 선언방식(2) className * ptrobj = new className ; // 동적 할당gcd 구하기과제로 제출한 최대공약수 구하는 코드였다.여기서 중간의이 코드는 불필요한 코드이다.논리적으로 나머지가 나누는 수보다 클 수 없으므로 불필요한 것이 되는 것이다.또한, 동기와 이 문제에 대해 이야기하다 생각해볼만한 거리를 얻었다.while (a%b!=0)을 조건으로 걸었을 때에는 gcd에 b를 최종적으로 할당하게 되지만,while (r!=0)을 조건으로 걸었을 때에는 gcd에 a를 최종적으로 할당하게 된다.그 원인은 while loop의 실행 횟수에 있었다.첫 번째 조건으로 실행하면 b에 gcd가 저장된 후 loop가 끝나지만,두 번째 조건으로 실행하면 한 번 더 while loop가 실행되 b에 있던 gcd 값이 a로 넘어간 뒤 loop가 종료된다.따라서 어떤 값을 할당해야 하느냐에 대한 차이가 있었고, loop의 작동 방식에 대해 깊이 생각해보는 계기가 되었다.한 가지 더 앞으로 생각해보아야 할 부분이 있다면,위의 코드에서 else를 묶느냐 안묶느냐에 따라 오류가 발생하는 것이다.else로 묶지 않으면 error가 발생하는데,왜 else로 묶어주어야하는지, 원인이 무엇인지를 앞으로 생각해보아야 할 과제이다." }, { "title": "REVIEW-Data_Structure_hw5", "url": "/posts/DATASTRUCTURE_HW5/", "categories": "STUDY, DATASTRUCTURE", "tags": "DATASTRUCTURE, TIL", "date": "2022-10-01 00:00:00 +0900", "snippet": "아래, 문제의 코드를 보자.#include &lt;iostream&gt;using namespace std;int main(int argac, char** argv){ int y=1; int *&amp; ry = &amp;y; cout &lt;&lt;ry&lt;&lt;endl; return 0;}💡 error가 발생한다 !!!오늘, C++ 공부...", "content": "아래, 문제의 코드를 보자.#include &lt;iostream&gt;using namespace std;int main(int argac, char** argv){ int y=1; int *&amp; ry = &amp;y; cout &lt;&lt;ry&lt;&lt;endl; return 0;}💡 error가 발생한다 !!!오늘, C++ 공부를 하다가 의문이 들어 다시 펼쳐보았다.아래의 포인터변수의 참조자 예시를 봅자.여기서*&amp;pref = ptr; 이것은int* (&amp;pref) = ptr;과 같은 표기라고 하며열혈 C++ 교재에는💡 포인터 변수의 참조자 선언도 &amp; 연산자를 하나 더 추가하는 형태로 진행이 된다. 이미 잘 아는 10행의 참조자 선언과 비교하기 바란다.라고 적혀있다.즉,오류가 발생하는 줄인int *&amp; ry = &amp;y;이 부분에서ry는 포인터 변수의 참조자 선언이라고 볼 수가 있는것이다.이렇게 했을 때 오류가 나니까 다시 한 번 확인할 수 있는 것.여기까지 동의하시나요 ?But !!&amp;y는 포인터변수가 아니지만 ! &amp;y를 포인터 변수에 대입하면 값이 똑같기때문에 이것도 문제가 없지 않나 ? 라는 의문이 들 수 있겠다error코드를 살펴보자.일단 reference to type ‘int*’이라는 말을 보면 포인터변수에 대한 참조자라는 것은 확실하다.그런데 !!!!여기서 Lvalue가 무엇인지, non-const value라는 말은 왜 나오는지, temporary라는 용어는 왜 나오는지 볼 필요가 있다.아래 사이트들을 한번씩 찬찬히 살펴보고 Lvalue와 Rvalue, &amp;와 &amp;&amp;에 대해 알아보았으면 좋겠다.http://hellocbc.blogspot.com/2021/01/c-lvalue-rvalue.html (이 사이트가 제일 도움이 될 것.)https://m.blog.naver.com/nortul/197601619https://effort4137.tistory.com/entry/Lvalue-Rvalue한번보면 이해 안돼도 이렇게 여러개 보면 대충 무슨 말인지 느낌이 올 것이다.그럼 이제 아래에 설명을 차근 차근 따라가보자.(출처는 첫 번째 사이트 !)Lvalue는 표현식 이후에 없어지지 않고 지속되는 객체로, 말하자면 선언식 중 왼쪽에 있는거, 예를 들면 선언된 변수 ! 를 이야기하는 것으로 추정됨 !Rvalue는 표현식 종료 후 더 이상 존재하지 않는 임시적인 값으로, 말하자면 선언식 중 오른쪽에 있는 것, 예를 들면 변수선언에 이용되는 값 일부 ?!? 로 생각.그런데 Lvalue와 Rvalue의 참조자 선언은 다르게 생겼다는 점 !우리 과제를 다시 한 번 보자.이제 이상한 부분이 보이지 않는가 ? !일단 포인터변수를 참조하기 위해 *&amp;ry를 사용했는데 오른쪽에 할당된 값은 &amp;y 이다 !!!!!!!!!!!&amp;y는 표현 식 종료 후 더 이상 존재하지 않는 임시적인 값으로 볼 수 있지 않을까? 그건 Rvalue라 위에서 그랬는데 !!!그럼 &amp;y 를 Rvalue라 생각하고 이 줄을 고쳐보자. Rvalue의 참조자 선언인 &amp;&amp;#include &lt;iostream&gt;using namespace std;int main(int argac, char** argv){ int y=1; int *&amp;&amp; ry = &amp;y; cout &lt;&lt;ry&lt;&lt;endl; return 0;}헉 ! 오류가 나타나지 않고 실행이 잘 된다 ! 이번에는 Lvalue로 만들어볼게용#include &lt;iostream&gt;using namespace std;int main(int argac, char** argv){ int y=1; int *k=&amp;y; int *&amp; ry = k; cout &lt;&lt;ry&lt;&lt;endl; return 0;}!!!!!!!포인터 변수 k를 선언해 y의 주소값을 받은 뒤 포인터변수의 참조자에 포인터변수를 할당해주면..오류가 나타나지 않고 실행이 잘 되는 것을 확인할 수 있다.즉, 위에서의 오류가 나는 원인은1. Rvalue와 Lvalue의 개념 때문이다2. *&amp;ry는 포인터변수의 참조자로, Rvalue를 참조해야하는데3. &amp;y는 Rvalue입니다.4. 따라서 우리는 Rvalue의 참조자인 *&amp;&amp;ry로 고쳐주거나5. &amp;y를 Lvalue로 만들어 포인터 변수를 만들어 참조를 하게되면6. 우리는 문제를 해결할 수 있겠네요💡 참조자 선언은 상수가 아닌 변수를 대상으로만 가능하다" }, { "title": "REVIEW-DBMS_LEC01_3", "url": "/posts/DBS103/", "categories": "STUDY, DBMS", "tags": "DBMS", "date": "2022-09-29 00:00:00 +0900", "snippet": "database system : lec-01-3Purpose of a Database purpose of a database to keep track of things store imformation that is more complicated than a simple list (or spreadsheet)Pr...", "content": "database system : lec-01-3Purpose of a Database purpose of a database to keep track of things store imformation that is more complicated than a simple list (or spreadsheet)Problems with Lists : Redundancy same information may be entered several times (쓸데없는 반복) (ex) a list of projects / 수강과목의 교수님 이름(young)의 반복 Multiple themes each row may contain information on more than one theme needed information may appear in the lists only if information on other temes is also present List Modification Issues Redundancy and multiple themes create modification problems Deletion problems Update problems Insertion problems (ex) student database (new guys ? young → ? )update, delete, insert data !Addressing the Information Complexities Relational databases are designed to address many of the information complexity issuesRelational Databases A relational database stores information in tables. Each information topic is stored in its own table In essence, a relational database will break-up(쪼개다) a list into several parts. One part for each theme in the list (ex.) A Project List would be divided into a CUSTOMER Table, a PROJECT Table, and a PROJECT_MANAGER TablePutting the Pieces Back Together In our relational database, we broke apart our list into several tables. Somehow the tables must be joined back together In a relational database, tables are joined together using the value of the data If a PROJECT has a CUSTOMER, the Customer_ID is stored as a column in the PROJECT table. The value stored in this column can be used to retrieve specific customer information from the CUSTOMER table 예를 들어, 위의 그림에서 ID를 통해 연결된 양상 확인 Sounds like More Work, Not Less A relational database is more complicated than a list However, a relational database minimizes data redundancy, preserves complex relationships among topics, and allows for partial data Furthermore, a relational database provides a solid foundation for user forms and reportsStructured Query Language (SQL) Structured Query Language (SQL) is an international standard for creating, processing and querying databases and their tables Many database applications use SQL to retrieve, format, report, insert, delete, and/or modify data for users Database management에 사용하는 international standard ⇒ SQLSQL Example We can use SQL to combine the data in the three tables in the Art Course Database to recreate the original list structure of the data. We do this by using an SQL SELECT statement example SELECT CUSTOMER.CustomerLastName, \t\tCUSTOMER.CustomerFirstName, \t\tCUSTOMER.Phone, \t\tCOURSE.CourseDate, ENROLLMENT.AmountPaid, \t\tCOURSE.Course, COURSE.Fee FROM CUSTOMER, ENROLLMENT, COURSE WHERE CUSTOMER.CustomerNumber \t\t\t\t\t= ENROLLMENT.CustomerNumber \tAND COURSE.CourseNumber \t\t\t\t\t= ENROLLMENT.CourseNumber; Database System The four components of a database system are : Users Use a database application to track things Use forms to enter, read, delete and query data produce reports Database Application Database Management System (DBMS) Database A database is a self-describing collection of related records Self-describing The database itself contains the definition of its structure Metadata is data describing the structure of the database data Tables within a relational database are related to each other users - Database Application - DBMS - Database User data, Metadata, Indexes and other overhead data, Application metadata Database Management System (DBMS) A database management system(DBMS) serves as an intermediary between database applications and the database The DBMS manages and controls database activities The DBMS creates, processes and administers the database it controlsFunctions of a DBMS Create database Create tables Create supporting structures Read database data Modify database data (insert, update, delete) Maintain database structures Enforce rules Control concurrency Provide security Perform backup and recoveryReferential Integrity Constraints The DBMS will enforce many constraints Referential integrity constraints ensure that the values of a column in one table are valid based on the values in another table PROJECT table의 customerID가 5라면 CUSTOMER table에 CUSTOMERID가 5인 고객이 있어야한다. Database Applications A database application is a set of one or more computer programs that serves as an intermediary between the user and DBMSFunctions of Database Applications Create and process forms Process user queries Create and process reports Execute application logic Control database applicationsPersonal Database Systems Personal database systemss typically: Have one application Have only a few tables Are simple in design Involve only one computer Support one user at a time PC에 database 설치 → personal database (ex. 김밥집 ~ 편의점은 회사 중앙서버 database라 personal이라고 할 수는 없음)Enterprise-Class Database Systems Enterprise-Class database systems typically: Support several users simultaneously Include more than one application Involve multiple computers Are complex in design Have many tables Have many databases " }, { "title": "TIL - Baekjoon", "url": "/posts/TIL/", "categories": "TIL, Baekjoon", "tags": "TIL", "date": "2022-09-26 11:55:44 +0900", "snippet": "3003. 킹, 퀸, 룩, 비숍, 나이트, 폰문제동혁이는 오래된 창고를 뒤지다가 낡은 체스판과 피스를 발견했다.체스판의 먼지를 털어내고 걸레로 닦으니 그럭저럭 쓸만한 체스판이 되었다하지만, 검정색 피스는 모두 있었으나, 흰색 피스는 개수가 올바르지 않았다.체스는 총 16개의 피스를 사용하며, 킹 1개, 퀸 1개, 룩 2개, 비숍 2개, 나이트 2개, ...", "content": "3003. 킹, 퀸, 룩, 비숍, 나이트, 폰문제동혁이는 오래된 창고를 뒤지다가 낡은 체스판과 피스를 발견했다.체스판의 먼지를 털어내고 걸레로 닦으니 그럭저럭 쓸만한 체스판이 되었다하지만, 검정색 피스는 모두 있었으나, 흰색 피스는 개수가 올바르지 않았다.체스는 총 16개의 피스를 사용하며, 킹 1개, 퀸 1개, 룩 2개, 비숍 2개, 나이트 2개, 폰 8개로 구성되어 있다.동혁이가 발견한 흰색 피스의 개수가 주어졌을 때, 몇 개를 더하거나 빼야 올바른 세트가 되는지 구하는 프로그램을 작성하시오.입력첫째 줄에 동혁이가 찾은 흰색 킹, 퀸, 룩, 비숍, 나이트, 폰의 개수가 주어진다. 이 값은 0보다 크거나 같고 10보다 작거나 같은 정수이다.출력첫째 줄에 입력에서 주어진 순서대로 몇 개의 피스를 더하거나 빼야 되는지를 출력한다. 만약 수가 양수라면 동혁이는 그 개수 만큼 피스를 더해야 하는 것이고, 음수라면 제거해야 하는 것이다.***#include &lt;stdio.h&gt;int main(void) { int k, q, r, b, n, p; scanf(\"%d %d %d %d %d %d\", &amp;k, &amp;q, &amp;r, &amp;b, &amp;n, &amp;p); printf(\"%d %d %d %d %d %d\", 1-k, 1-q, 2-r, 2-b, 2-n, 8-p );}#include &lt;iostream&gt;using namespace std;int main() { int k, q, r, b, n, p; cin&gt;&gt;k&gt;&gt;q&gt;&gt;r&gt;&gt;b&gt;&gt;n&gt;&gt;p; cout&lt;&lt;1-k&lt;&lt;' '&lt;&lt;1-q&lt;&lt;' '&lt;&lt;2-r&lt;&lt;' '&lt;&lt;2-b&lt;&lt;' '&lt;&lt;2-n&lt;&lt;' '&lt;&lt;8-p;}*** My first github! 😊오늘은 첫날이라 워밍업! 한다는 느낌으로 쉬운 문제 하나를 C언어와 C++언어로 구현해보았다.앞으로는 1일 1백준을 꾸준히 실천하며, 다양한 문제 상황을 접함과 동시에 문제 해결 방법을 탐구하면서 공부를 하면 할수록 점점 잊혀져 가는 것이 아닌, 배운 내용들을 쌓아가는 공부를 하고 싶다." } ]
